{"name":"datomic-cljs","tagline":"A Clojure-like Datomic API for ClojureScript","body":"**[Install](#install)** |\r\n**[Minimum Viable Snippet](#minimum-viable-snippet)** |\r\n**[Using Datomic REST](#using-datomic-rest)** |\r\n**[API Overview](#api-overview)** |\r\n**[Limitations](#limitations)** |\r\n**[Testing](#testing)**\r\n\r\n# ClojureScript, meet Datomic\r\n\r\ndatomic-cljs provides an interface to Datomic that is as close as possible to the native [Clojure API](http://docs.datomic.com/clojure/index.html).\r\nIt approximates Clojure's blocking API with [core.async](https://github.com/clojure/core.async).\r\nIt supports both Node.js and modern browsers.\r\n\r\n_**Warning:** This is incomplete, alpha software. Everything is subject to change._\r\n\r\n## Install\r\n\r\n**Leiningen**\r\n\r\n```clj\r\n[com.zachallaun/datomic-cljs \"0.0.1-alpha-1\"]\r\n```\r\n\r\n**npm**\r\n\r\nIf you're targeting Node, datomic-cljs has an additional dependency.\r\nAdd the following to your `package.json`:\r\n\r\n```js\r\n\"dependencies\" : {\r\n  \"request\" : \"2.27.0\"\r\n}\r\n```\r\n\r\n## Minimum Viable Snippet\r\n\r\n```clj\r\n(ns example\r\n  (:require [datomic-cljs.api :as d]\r\n            [cljs.core.async :refer [<!]])\r\n  (:require-macros [cljs.core.async.macros :refer [go]]))\r\n\r\n(go\r\n  (let [conn (d/connect \"localhost\" 9898 \"local\" \"friends\")\r\n        eid (ffirst (<! (d/q '[:find ?e :where [?e :person/name \"Frank\"]]\r\n                             (d/db conn))))]\r\n    (<! (d/transact conn [[:db/add eid :person/name \"Franky\"]]))))\r\n```\r\n\r\nThis queries a datomic database for a person named `\"Frank\"` and changes his name to be `\"Franky\"`.\r\n\r\n## Using Datomic REST\r\n\r\ndatomic-cljs talks to a Datomic database through the Datomic REST service.\r\nDatomic REST is a standalone server that sits in front of a transactor and exposes Datomic through HTTP.\r\n\r\nFor the sake of these examples, I'll assume that you're using [Datomic Free](https://my.datomic.com/downloads/free) and that you have a `DATOMIC_HOME` environment variable set, pointing to the directory of your peer library.\r\n\r\nFirst, start a transactor.\r\n\r\n```sh\r\n$ $DATOMIC_HOME/bin/transactor $DATOMIC_HOME/config/samples/free-transactor-template.properties\r\n```\r\n\r\nBy default, this will start a Datomic Free transactor at `datomic:free://localhost:4334/`.\r\nWith a transactor in place, you can start the Datomic REST service.\r\nIf you're planning to use datomic-cljs in the browser, you'll have to include the `--origins` flag to specify allowed origins for cross-origin resource sharing.\r\nIf you're planning to use datomic-cljs on node, `--origins` can be omitted from the following.\r\n\r\n```sh\r\n$ $DATOMIC_HOME/bin/rest --port 9898 --origins http://0.0.0.0:8000 local datomic:free://localhost:4334/\r\n```\r\n\r\nThe `rest` script accepts repeated alias/transactor pairs.\r\n`local` is an alias that specifies your transactor.\r\n\r\nOnce you have the service running, you can visit http://localhost:9898 in your browser to see documentation for the REST API and interact with the service through web forms.\r\n\r\n## API Overview\r\n\r\nIn general, datomic-cljs exposes the same API as its Clojure counterpart.\r\nBut, where the Clojure library would block awaiting a result to communicate, datomic-cljs returns a core.async channel.\r\nTo learn more about core.async, I recommend David Nolen's article [Communicating Sequential Processes](http://swannodette.github.io/2013/07/12/communicating-sequential-processes/) and the [core.async API documentation](http://clojure.github.io/core.async/).\r\n\r\nSee [examples/friends.cljs](/examples/friends.cljs) for an example of much of what follows.\r\n\r\n### Namespaces of Interest\r\n\r\n```clj\r\n(defn example\r\n  (:require [datomic-cljs.api :as d])\r\n  (:require-macros [datomic-cljs.macros :refer [<?]]))\r\n```\r\n\r\nEverything exciting happens in `datomic-cljs.api`, with the exception of the single `<?` macro from `datomic-cljs.macros`.\r\n(See [Error Handling](#error-handling) for information on `<?`.)\r\n\r\n### Creating and Connecting to Databases\r\n\r\n#### Create a connection to an existing database\r\n\r\n```clj\r\n(def conn (d/connect \"localhost\" ;; hostname of your running REST service\r\n                     9898        ;; port\r\n                     \"local\"     ;; transactor alias\r\n                     \"friends\")) ;; database name\r\n```\r\n\r\nThis returns a core.async channel that will contain either a database connection or an error.\r\n\r\n#### Create a database\r\n\r\n```clj\r\n(go\r\n  (let [conn (<? (d/create-database \"localhost\" 9898 \"local\" \"friends\"))]\r\n    ...))\r\n```\r\n\r\nAccepts the same arguments as `connect`, but will attempt to create a new database, connecting to it if it already exists.\r\nThis returns a core.async channel that will contain either a database connection or an error.\r\n\r\n\r\n### Database Values, Query, Entity, and Transactions\r\n\r\nFor the most part, these are quite similar to their Clojure API counterparts, except that they return c\r\nore.async channels eventually containing either results or errors.\r\n(See the [Datomic reference](http://docs.datomic.com/) for more information on what's possible.)\r\n\r\n#### Differences\r\n\r\n##### `datomic-cljs.api/entity`\r\n\r\nThis function differs in two ways.\r\nIts result is just a plain hash-map, in contrast to the Clojure API's lazily-evaluating, hash-map-like Entity object.\r\nAttributes in the Entity that are refs to other entities will not contain nested entity maps.  Instead, they will contain entity ids.\r\nThis avoids circular references.\r\nTo access nested entities, you'll have to pass the entity ids back to `datomic-cljs.api/entity`.\r\n\r\n```clj\r\n(go\r\n  (let [db (d/db conn)\r\n        [[eid]] (<? (d/q '[:find ?e :where [?e :person/name \"Caroll\"]] db))\r\n        friends (->> (<? (d/entity db eid))\r\n                     :person/friends\r\n                     (map #(d/entity db %)))]\r\n    (<? (first friends))))\r\n```\r\n\r\n##### `datomic-cljs.api/limit`\r\n\r\nAdded.\r\nThis limits the results to a certain number.\r\nIt composes in the same way as the other query operations.\r\n\r\n##### `datomic-cljs.api/offset`\r\n\r\nAdded.\r\nThis begins returning results at a certain number.\r\nIt composes in the same way as the other query operations.\r\n\r\n### Error Handling\r\n\r\nErrors are put directly on return channels.\r\nTo keep from wrapping each parking take in a conditional, `datomic-cljs.macros/<?` is introduced.\r\nInstead of `cljs.core.async/<!`, use `datomic-cljs.macros/<?` to take from channels.\r\nIf a `js/Error` is taken, it will be thrown.\r\nHere's the Minimum Viable Snippet rewritten to handle errors:\r\n\r\n```clj\r\n(ns example\r\n  (:require [datomic-cljs.api :as d]\r\n            [cljs.core.async :refer [<!]])\r\n  (:require-macros [cljs.core.async.macros :refer [go]]\r\n                   [datomic-cljs.macros :refer [<?]]))\r\n\r\n(go\r\n  (try\r\n    (let [conn (d/connect \"localhost\" 9898 \"local\" \"friends\")\r\n          eid (ffirst (<? (d/q '[:find ?e :where [?e :person/name \"Frank\"]]\r\n                               (d/db conn))))]\r\n      (<? (d/transact conn [[:db/add eid :person/name \"Franky\"]])))\r\n    (catch js/Error e\r\n      (println \"Something went wrong!\"))))\r\n```\r\n\r\n## Limitations\r\n\r\nThere's work left to be done.\r\nFor missing pieces of the API, see the bottom of [api.cljs](/src/datomic_cljs/api.cljs).\r\n\r\nThings we don't have but probably should:\r\n\r\n1. For the browser, some kind of authentication story.\r\nTransaction is currently wide open.\r\n- Much better test coverage, including tests for things like malformed input.\r\n\r\n## Testing\r\n\r\nI've developed super-awesome testing infrastructure to manage the inherent asynchrony.\r\nIt involves shoving errors into a vector and printing it.\r\nIf the vector's empty, there are no errors and we rejoice.\r\n\r\nAssumptions are documented at the top of [t_api.cljs](https://github.com/zachallaun/datomic-cljs/blob/master/test/datomic_cljs/t_api.cljs#L11).\r\n\r\n### Node\r\n\r\n```sh\r\n$ lein cljsbuild once\r\n$ node target/test.js\r\n```\r\n\r\n### Browser\r\n\r\n```sh\r\n$ lein cljsbuild once\r\n$ python -m SimpleHTTPServer 8000 # then visit 0.0.0.0:8000\r\n```\r\n\r\nThis will serve the project root.\r\nNavigate to the index, which will include the browser tests, and open the console to see the results.\r\n\r\n_Note:_ You may see nasty CORS-related errors in the browser tests.\r\nThey're unavoidable.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}